#!/usr/bin/env python
# -*- coding: utf-8 -*-
import ipdb
from time import sleep
from itertools import islice
#
import os.path as osp
import re
import numpy as np
import climax as clx
from ploteries2 import Reader, Writer, GenericScalarsManager, PlotsManager, HistogramsManager
from ploteries2._ploteries2_helper import get_train_args
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_daq as daq
from dash.dependencies import Input, Output, State
from dash.exceptions import PreventUpdate
from plotly import graph_objects as go
import plotly.express as px
from multiprocessing import cpu_count
from pglib.gunicorn import GunicornServer

external_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']
#
global DB_PATH, HEIGHT, WIDTH, LARGE_HEIGHT, LARGE_WIDTH, APP, SLIDER_GROUP
HEIGHT, WIDTH = None, None
global GRAPH_KWARGS
GRAPH_KWARGS = {}  # {'config': {'displayModeBar': True}}
global FIGURE_LAYOUT


def update_figure_layout():
    global FIGURE_LAYOUT
    FIGURE_LAYOUT = dict(
        height=HEIGHT, width=WIDTH,
        margin=go.layout.Margin(**dict(zip('lrbt', [0, 30, 0, 0]), pad=4)),
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1),
        modebar=dict(
            orientation='v'))


update_figure_layout()

#
APP = dash.Dash(__name__, external_stylesheets=external_stylesheets)

# Helper functions.

CONTROL_WIDGET_STYLE = {'float': 'left', 'margin': '0em 1em 0em 1em'}


class SliderGroup(object):
    def __init__(self):
        self.ids = []

    def add(self, id, *args, register=True, **kwargs):
        slider = dcc.Slider(id=id, *args, **kwargs)
        if register:
            self.ids.append(id)
        return slider

    def create_callbacks(self):

        @ APP.callback(
            Output("global-step-dropdown", "options"),
            [Input(slider_id, "marks") for slider_id in self.ids]
        )
        def update_global_step_options(self, *slider_marks):
            # Get all marks.
            all_marks = set()
            for _marks in slider_marks:
                if _marks:
                    all_marks = all_marks.union(_marks)
            all_marks = sorted(all_marks)
            # Return options
            return [{'label': str(_x), 'value': int(_x)} for _x in all_marks]

        @ APP.callback(
            Output('global-step-dropdown', 'disabled'),
            [Input('auto-update-switch', 'value')]
        )
        def require_auto_update_disabled(value):
            return bool(value)


# def iter_safe_names(reader, content_type):
#     return [(content_type+'-'+str(_t['id']) + '-'+re.sub('[^0-9a-zA-Z]+', '-', _t['name']), _t['name'])
#             for _t in reader.tables_of_type(content_type)]


def group_plots(tags_and_figures, depth=1):
    # Groups figures into html Summaries based on table name.
    # figures: [(table_name, dcc/html), ... ]
    group_ids = [('/'.join(figure_tag.split('/')[:depth]), html)
                 for figure_tag, html in tags_and_figures]
    groups = {}

    # Create groups.
    for group_id, content in group_ids:
        groups.setdefault(group_id, []).append(content)

    # Append content to html details
    output = [html.Details([html.Summary(group_id), html.Div(
        content)], open=True) for group_id, content in groups.items()]

    return output


def LoadingGraph(figure=None, **kwargs):
    if figure is None:
        figure = {'data': [], 'layout': {
            'width': WIDTH, 'height': HEIGHT}, 'frames': []}
        figure = go.Figure()
        figure.update_layout(**FIGURE_LAYOUT)
    # return dcc.Loading(dcc.Graph(*args, **kwargs))
    return dcc.Graph(figure=figure, **kwargs, **GRAPH_KWARGS)

# Layout creation


def create_layout(reader, update_interval):
    global APP

    # Init reader
    if reader is None:
        reader = Reader(DB_PATH)

    # Build HTML for all graphs
    def _skip(sel, val): return [val] if sel else []

    def build_graph_html(fig_tag, fig_name, auto=False, expand=True, slider=False):
        out = html.Div([
            html.Div(fig_tag), LoadingGraph(id=fig_name)] +
            _skip(auto or expand, html.Div(
                _skip(auto, dcc.Checklist(id='auto-'+fig_name,
                                          options=[
                                              {'label': 'auto', 'value': 'auto'}],
                                          value=['auto'], style={'display': 'inline'})))) +
            _skip(slider, html.Div([SLIDER_GROUP.add(id='slider-'+fig_name, step=None, register=slider,
                                                     tooltip={'always_visible': False,
                                                              'placement': 'top'},
                                                     updatemode='mouseup')])),
            style={'display': 'inline-block', 'margin': '1em'})
        return out

    def get_graphs_of_type(manager_type, **kwargs):

        graphs = [(_fig.tag, build_graph_html(_fig.tag, _fig.name, **kwargs))
                  for _fig in reader.load_figure_recs(manager_super=manager_type)]
        # graphs = [(_fig.tag, build_graph_html(_fig.tag, _fig.name, **kwargs))
        #          for _fig in reader.load_figure_recs(manager=manager_type)]
        graphs = group_plots(graphs)
        return graphs
    #
    # reader.load_figure_recs(manager=GenericScalarsManager)
    scalars = get_graphs_of_type(GenericScalarsManager)
    figures = get_graphs_of_type(PlotsManager, slider=True)
    histograms = []  # get_graphs_of_type(HistogramsManager, slider=True)

    # Layout
    layout = html.Div(
        children=[
            html.Div([
                html.H2(children='Ploteries', style={
                        'float': 'right', 'margin-right': '1em', 'font-family': 'Courier New'}),
                # html.Div([
                html.Div([
                    daq.ToggleSwitch(id='auto-update-switch', size=20,
                                     value=True,
                                     label=' ',
                                     style=CONTROL_WIDGET_STYLE),  # 'display': 'inline-block'
                    html.Label(['Global step:', dcc.Dropdown(
                        id='global-step-dropdown')], style=dict(**{'min-width': '20em'}, **CONTROL_WIDGET_STYLE))], )
            ], style={'content': "", 'clear': 'both', 'display': 'table', 'width': '100%'}),
            # ]),
            dcc.Tabs([
                dcc.Tab(label='Scalars', children=scalars),
                dcc.Tab(label='Figures', children=figures),
                dcc.Tab(label='Histograms', children=histograms),
                dcc.Tab(label='Settings', children=get_train_args(reader))]),
            dcc.Interval(
                id='interval-component',
                interval=update_interval*1000,  # in milliseconds
                n_intervals=0
            )]
    )
    return layout

# # Resize callbacks.
# def expand_graph(large=False):
#     print('****** large: ', large)
#     if large: return (LARGE_WIDTH, LARGE_HEIGHT)
#     else: return (WIDTH, HEIGHT)
# def create_expand_callbacks(reader):
#     _g=globals()
#     for tbl_safe_name,tbl_name in \
#         iter_safe_names(reader, 'Float') + \
#         iter_safe_names(reader, 'FigureType') + \
#         iter_safe_names(reader, 'HistogramType'):
#         _g['expand_graph_'+tbl_safe_name] = APP.callback(
#             [Output(tbl_safe_name, 'figure.layout.height'),
#              Output(tbl_safe_name, 'figure.layout.width')],
#             [Input('expand-'+tbl_safe_name, 'value')])(
#                 lambda large: expand_graph(large))


def update_scalar(figure_name):
    reader = Reader(DB_PATH)
    figure_rec = reader.load_figure_recs(name=figure_name)[0]
    fig = reader.load_figure(figure_rec)
    fig.update_layout(**FIGURE_LAYOUT)

    return fig


def create_toolbar_callbacks():
    # Auto update switch
    def auto_update_switch(enabled):
        enabled = bool(enabled)
        return not enabled, 'Auto update '+['disabled', 'enabled'][enabled]
    _g = globals()
    _g['auto_update_switch'] = APP.callback(
        [Output('interval-component', 'disabled'),
         Output('auto-update-switch', 'label')],
        [Input('auto-update-switch', 'value')]
    )(auto_update_switch)


def create_update_scalar_callbacks(reader):
    _g = globals()
    for _fig in reader.load_figure_recs(manager_super=GenericScalarsManager):
        # import ipdb
        # ipdb.set_trace()
        _g['update_scalar_'+_fig.name] = APP.callback(
            Output(_fig.name, 'figure'),
            [Input('interval-component', 'n_intervals')])(
                lambda _n, _fig_name=_fig.name: update_scalar(_fig_name))

# Retrieve graph callbacks
# Input: slider.value, Output:graph.figure


def retrieve_graph(global_step, figure_name):
    # Can happen when sliders are not yet initialized.
    if global_step is None:
        raise PreventUpdate
    #
    reader = Reader(DB_PATH)
    records = reader.load_figure_recs(name=figure_name)
    #
    if len(records) > 1:
        raise Exception('Unexpected error!')
    elif len(records) == 0:
        figure = go.Figure()
    else:
        figure = reader.load_figure(records[0], manager_kwargs={
            'global_step': global_step})
    #
    figure.update_layout(**FIGURE_LAYOUT)

    return figure


# TODO
def update_slider(figure_name, slider_value, slider_output_keys):
    reader = Reader(DB_PATH)
    #
    _marks = reader.global_steps(name=figure_name)
    marks = dict(zip(_marks, ['']*len(_marks)))
    if len(marks) > 0:
        for _m in [_marks[0], _marks[-1]]:
            marks[_m] = str(_m)
    min_mark = min(_marks)
    max_mark = max(_marks)
    val = max_mark
    #
    slider_state = {'marks': marks, 'min': min_mark,
                    'max': max_mark, 'value': val, 'disabled': len(marks) == 1}
    return tuple([slider_state[key] for key in slider_output_keys])
#


def create_graph_callbacks(reader, figure_type):
    _g = globals()

    for fig_rec in reader.load_figure_recs(manager_super=figure_type):
        slider_name = 'slider-'+fig_rec.name

        # Retrieve graph callbacks
        _g['retrieve_graph_'+fig_rec.name] = APP.callback(
            Output(fig_rec.name, 'figure'),
            [Input(slider_name, 'value')])(
                lambda _gs, fig_name=fig_rec.name:
                retrieve_graph(_gs, figure_name=fig_name))

        # # Update slider callbacks
        # slider_output_keys=['marks', 'min', 'max', 'value', 'disabled']
        # _g['update_slider_'+tbl_safe_name] = APP.callback(
        #     [Output(slider_name, _x) for _x in slider_output_keys],
        #     [Input('interval-component', 'n_intervals')],
        #     [State(slider_name, 'value')])(
        #         lambda _, slider_value,tbl_name=tbl_name,slider_output_keys=slider_output_keys:
        #         update_slider(tbl_name, slider_value,slider_output_keys))

        # Update slider callbacks
        slider_output_keys = ['marks', 'min', 'max', 'value', 'disabled']

        @ APP.callback(
            [Output(slider_name, _x) for _x in slider_output_keys],
            [Input('interval-component', 'n_intervals'),
             Input('global-step-dropdown', 'value'),
             Input('global-step-dropdown', 'disabled')],
            [State(slider_name, _x) for _x in slider_output_keys])
        def update_slider(n_intervals, global_step, global_step_disabled, *slider_state,
                          figure_name=fig_rec.name, slider_output_keys=slider_output_keys):
            reader = Reader(DB_PATH)
            # Global step specified
            if not global_step_disabled and global_step is not None:
                slider_state = dict(zip(slider_output_keys, slider_state))
                slider_state['value'] = global_step
                return [slider_state[key] for key in slider_output_keys]

            # Auto update
            _marks = reader.global_steps(name=figure_name)
            marks = dict(zip(_marks, ['']*len(_marks)))
            if len(marks) > 0:
                for _m in [_marks[0], _marks[-1]]:
                    marks[_m] = str(_m)
            min_mark = min(_marks)
            max_mark = max(_marks)
            val = max_mark
            #
            slider_state = {'marks': marks, 'min': min_mark,
                            'max': max_mark, 'value': val, 'disabled': len(marks) == 1}
            return tuple([slider_state[key] for key in slider_output_keys])


#####
_wd = 550


@ clx.group()
def main():
    pass


@ clx.parent()
@ clx.argument('path', help='Ploteries database file path.')
def path_arg():
    pass


@ main.command(parents=[path_arg])
@ clx.option('--interval', type=float, help='Seconds between automatic update of all plots.', default=300)
@ clx.option('--debug', action='store_true', help='Enables javascript debug console', default=False)
@ clx.option('--host', help='Host name.', default='0.0.0.0')
@ clx.option('--port', help='Port number.', default='8000')
@ clx.option('--workers', help='Number of workers (ignored in debug mode).', default=(cpu_count() * 2) + 1)
@ clx.option('--height', help='Figure height,', type=int, default=_wd*(2/3))
@ clx.option('--width', help='Figure width,', type=int, default=_wd)
def launch(path, debug, host, interval, height, width, port, workers):
    """
    Launch a ploteries visualization server.
    """
    #
    global DB_PATH, HEIGHT, WIDTH, LARGE_HEIGHT, LARGE_WIDTH, SLIDER_GROUP
    DB_PATH = path
    HEIGHT = height
    WIDTH = width
    LARGE_HEIGHT = 2*HEIGHT
    LARGE_WIDTH = 2*WIDTH
    update_figure_layout()
    reader = Reader(DB_PATH)
    #
    # APP.layout = create_layout(reader, update_interval=interval)
    SLIDER_GROUP = SliderGroup()
    APP.layout = lambda: create_layout(None, update_interval=interval)
    # TODO : Enable these
    create_graph_callbacks(reader, PlotsManager)
    #create_graph_callbacks(reader, HistogramsManager)
    create_update_scalar_callbacks(reader)
    create_toolbar_callbacks()
    SLIDER_GROUP.create_callbacks()
    # create_expand_callbacks(reader)

    if debug:
        APP.run_server(debug=debug, host=host, port=port)
    else:
        options = {
            'bind': '%s:%s' % (host, port),
            'workers': workers,
            'timeout': 180,
        }
        GunicornServer(APP.server, options).run()


@ main.command(parents=[path_arg])
@ clx.option('--overwrite', action='store_true', help='overwrite database', default=False)
def create_test_db(path, overwrite):
    """
    Create a test database.
    """
    if overwrite:
        with open(path, 'w'):
            pass
    elif osp.isfile(path):
        raise Exception('File already exists.')

    # Data generation
    def random_walk(start=0, var=1.0):
        val, std = start, var**0.5
        while True:
            yield val + np.random.randn()*(std/10)
            val += np.random.randn()*std

    def random_walks(N=3, start=0, var=1.0):
        walkers = [iter(random_walk(start=start, var=var)) for _ in range(N)]
        while True:
            yield [next(_w) for _w in walkers]

    writer = Writer(path)
    k = -1
    N = 3
    scalars1 = iter(random_walks(N=N))
    scalars2 = iter(random_walks(N=N))
    plot1 = iter(random_walk())
    plot2 = iter(random_walk())
    histo1 = iter(random_walk())
    histo2 = iter(random_walk())
    while True:
        k += 1
        print(k)
        # Add scalars
        writer.add_scalars('scalars/scalars1', next(scalars1), k,
                           names=[f'plot{_l}' for _l in range(N)])
        writer.add_scalars('scalars/scalars2', next(scalars2), k)

        # Add plots
        X = list(range(50))
        if k % 100 == 0:
            writer.add_plots('plots/plot1', [(X, list(islice(plot1, 50))) for _ in range(N)], k,
                             names=[f'plot{_l}' for _l in range(N)])
            writer.add_plots('plots/plot2', [(X, list(islice(plot2, 50))) for _ in range(N)], k,
                             names=[f'plot{_l}' for _l in range(N)])

        # Add histograms
        if k % 100 == 0:
            writer.add_histograms('histograms/histogram1', [list(islice(histo1, 1000)) for _ in range(N)], k,
                                  names=[f'histo{_l}' for _l in range(N)])
            writer.add_histograms('histograms/histogram2', [list(islice(histo2, 1000)) for _ in range(N)], k,
                                  names=[f'histo{_l}' for _l in range(N)])

        # Sleep
        sleep(.5)


if __name__ == '__main__':
    main()
